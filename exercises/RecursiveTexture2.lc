
len2 v = v%x*v%x + v%y*v%y + v%z*v%z

makeFrame2 (time :: Float)
          (projmat :: Mat 4 4 Float)
          (vertexstream :: Stream (Primitive Triangle (Vec 4 Float)))

    = imageFrame (emptyDepthImage 1000, emptyColorImage navy)
  `overlay`
      vertexstream
    & mapPrimitives (\x -> (scale 0.5 (projmat *. x), x))
    & rasterizePrimitives (TriangleCtx CullNone PolygonFill NoOffset LastVertex) Smooth
    & filterFragments ffilter
    & accumulateWith (DepthOp Less True, ColorOp NoBlending (V4 True True True True))
  where
    h = 0.25

    ffilter v =
           (v%y + v%x + v%z > 1 || abs (v%y - v%x + v%z - 1.0) > h)
        && (v%y + v%x - v%z > 1 || abs (v%y + v%x + v%z - 1.0) > h)
        && (v%y - v%x - v%z > 1 || abs (v%y + v%x - v%z - 1.0) > h)
        && (v%y - v%x + v%z > 1 || abs (v%y - v%x - v%z - 1.0) > h)
        && len2 v' > abs (3 * sin (1 * time))
      where
        v' = sin (v *! 20)

inner2 =
   makeFrame2 (Uniform "Time")
             (Uniform "MVP")
             (fetch_ "stream4" (Attribute "position4"))

clear = imageFrame (emptyDepthImage 1000, ColorImage @1 navy)

triangleRasterCtx = TriangleCtx CullBack PolygonFill NoOffset LastVertex
colorFragmentCtx = (DepthOp Less True, ColorOp NoBlending (V4 True True True True))

cubeVertexStream = fetch "stream4" Triangle (Attribute "position4" :: Vec 4 Float, Attribute "vertexUV" :: Vec 2 Float)
rotMatrix = Uniform "MVP" :: Mat 4 4 Float

setAlpha v = v * V4 1.0 1.0 1 0 + V4 0 0 0 1

cube' (n :: Float) fb =
       clear
   `overlay`
       cubeVertexStream
     & mapPrimitives (\(v, u) -> (rotMatrix *. scale 0.5 (rotMatrixX (-n/5) *. v), u))
     & rasterizePrimitives triangleRasterCtx Smooth
     & mapFragments (\a -> setAlpha $ (a%xxyy *! 0.7 + texture2D sampler a) *! 0.7)
     & accumulateWith colorFragmentCtx
  where
    sampler = Sampler LinearFilter MirroredRepeat $ Texture2D (V2 512 512) (PrjImageColor fb)

main :: Output
main = ScreenOut $ snd $ iterate (\(n, f) -> (n+1, cube' n f)) (0, inner2) !! 2

